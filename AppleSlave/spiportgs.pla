//
// WIRING CONSTANTS FOR ARDUINO
//
CONST PINHIGH   = 1
CONST PINLOW    = 0
CONST PINOUTPUT = 1
CONST PININPUT  = 0
CONST PINPULLUP = 2
//
// BIT BANGED SPI OVER GAMEPORT - WILL WORK WITH APPLE II GS
//
BYTE[] SPIXFER
BYTE[] = $8D, $5A, $C0 // STA $C05A   ENABLE SLAVE
BYTE[] = $A0, $00      // LDY #0      ASSUME MSB IS ZERO
BYTE[] = $B5, $C0      // LDA $C0,X   GET ARGUMENT
BYTE[] = $10, $01      // BPL +01     CHECK MSB
BYTE[] = $C8           // INY         IT'S A ONE
BYTE[] = $99, $58, $C0 // STA $C058,Y WRITE BIT 7
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0      DOING THIS HERE GIVES TIME FOR OUTPUT TO BECOME STABLE
BYTE[] = $0E, $61, $C0 // ASL $C061   READ BIT 7 INTO CARRY
BYTE[] = $2A           // ROL         ROTATE INTO ACC
BYTE[] = $10, $01      // BPL +01     REPEAT FOR ALL BITS
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $2A           // ROL
BYTE[] = $10, $01      // BPL +01
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $2A           // ROL
BYTE[] = $10, $01      // BPL +01
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $2A           // ROL
BYTE[] = $10, $01      // BPL +01
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $2A           // ROL
BYTE[] = $10, $01      // BPL +01
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $2A           // ROL
BYTE[] = $10, $01      // BPL +01
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $A0, $00      // LDY #0
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $2A           // ROL
BYTE[] = $10, $01      // BPL +01
BYTE[] = $C8           // INY
BYTE[] = $99, $58, $C0 // STA $C058,Y
BYTE[] = $8D, $5C, $C0 // STA $C05C   CLOCK LO
BYTE[] = $8D, $5D, $C0 // STA $C05D   CLOCK HI
BYTE[] = $0E, $61, $C0 // ASL $C061
BYTE[] = $8D, $5B, $C0 // STA $C05B     DISABLE SLAVE
BYTE[] = $2A           // ROL
BYTE[] = $95, $C0      // STA $C0,X     SAVE RETURN PARAMETER
BYTE[] = $60           // RTS

BYTE SPIDATA

DEF DELAY(TIME)
  RETURN CALL($FCA8, TIME, 0, 0, 0)
END

DEF SPISEND(DATA)
  BYTE TIMEOUT, STATUS

  FOR TIMEOUT = 10 DOWNTO 0
    STATUS = (@SPIXFER)(DATA)
    IF STATUS <> $FF
      RETURN STATUS
    FIN
    PUTC(STATUS)
    DELAY(50)
  NEXT
  PUTC('!')
  RETURN -1
END

DEF SPIRECV
  RETURN (@SPIXFER)(0)
END

DEF SPIRESET
  ^$C05D // CLOCK HIGH
  ^$C05B // SS HIGH
  RETURN SPISEND(0)
END

SPIRESET
PUTS("ARDUINO HARDWARE:")
SPISEND(2);PUTI(SPIRECV);PUTC(13) // HWMODEL
SPISEND(3);SPISEND(13);SPISEND(PINOUTPUT) // PINMODE(PIN,VAL)
SPIDATA = 0
REPEAT
  IF ^$C000 > 127
    ^$C010
    SPIDATA = ^$C000
    SPISEND(11);SPISEND(SPIDATA) // SERIALWRITE(CHR)
    SPISEND(5);SPISEND(13);SPISEND(SPIDATA & 1) // DIGITALWRITE(PIN,VAL)
  FIN
UNTIL SPIDATA == 27
^$C010
DONE
